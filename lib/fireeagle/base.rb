#The base class for interfacing w/ FireEagle
#
#  @fireeagle = Fireagle::Base.new(:token => "foo", :secret => "bar")
#
#Fire Eagle (FE) is a system providing centralized management of user location information. FE allows 3rd party developers to update and/or access user's location data.
#
#There are 3 data entities at Fire Eagle's core:
# 
#* User: Users can grant 3rd party applications privileges to read or write the user's location data. Users identify themselves to the FE system with their Yahoo! username/password. Applications identify a user with an application-specific user token (referred to in the API as a userid) generated by FE.
#* Application: An application is identified by system-wide application token. Applications use this token (referred to in the API as an appid) and an application-specific secret to identify themselves to FE when reading or writing user location data.
#* Location: FE stores the most recent location supplied by each application for each user. Applications can specify location in a number of ways: e.g. a latitude/longitude pair, a postal code, a street address, a GSM cell tower identifier, or an identifier from an external system (Plazes, Upcoming.org, etc.). See the Update API section for all possible location input options.
# 
#Only one location per user-application pair is stored, thus FE provides access only to a user's current location, not a location history of where the user has been. When a user's location is requested FE combines location info from one or more applications into a current best guess location record which is returned in XML format -- see the Query API Response section, below for details.
class FireEagle::Base
  
  attr_reader :token, :secret
  
  #Create a new FireEagle::Base object.
  #
  # @fireeagle = Fireagle::Base.new(:token => "foo", :secret => "bar")
  def initialize(options = {})
    options = { :token => nil, :secret => nil }.merge(options)
    raise FireEagle::ArgumentError, "Token and Secret required" if options[:token].nil? || options[:secret].nil?
    @token = options[:token]
    @secret = options[:secret]
    @fireeagle = self
  end
  
  # Return an instance of FireEagle::Application
  def application() @application ||= FireEagle::Application.new(self) end

private

  # do the required api signing
  def encode_and_sign(params = {})

    #check for the params
    raise ArgumentError, "Params required" if params == {} || !params.is_a?(Hash)

    #remove any provided sig
    params.delete(:sig)

    #add the app token id
    params[:appid] = @fireeagle.token

    #sort and URL encode the params
    normalized_params = {}
    params.each_pair { |name, value| normalized_params[name.to_s] = value.to_s }

    #build the string to sign
    sig = "#{@fireeagle.secret}"
    normalized_params.sort.each { |name, value| sig << "#{name}#{value}" } 

    #sign it
    normalized_params['sig'] = Digest::SHA1.hexdigest(sig)

    #create and return the request string
    request_string = "?" + normalized_params.sort.collect { |name, value| "#{name}=#{CGI::escape(value)}" }.join('&')
  end

  # request method which is used by all public methods
  def request(action = nil,params = {})
    raise ArgumentError, "Action name required" if action.nil?

    #reject crap
    params.reject { |key, value| value.nil? or (value.is_a?(String) and value.empty?)}
    #merge timestamp
    params.merge!( { :timestamp => Time.now.to_i } )

    path = "#{FireEagle::API_PATH}#{action}.php#{encode_and_sign(params)}"
    
    puts path if FireEagle::DEBUG

    response = Net::HTTP.get_response(FireEagle::API_DOMAIN, path)
    
    parse_response(Hpricot(response.body))   
  end
  
  def parse_response(doc)
    raise FireEagleException, doc.at("/resultset/errormessage").innerText unless !doc.at("/resultset").nil? and doc.at("/resultset/error").innerText.to_i == "0"
    doc.at("/result")
  end
  
  def fireeagle
    fireeagle
  end
  
  
end